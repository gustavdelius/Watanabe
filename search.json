[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Watanabe’s Singular Learning Theory",
    "section": "",
    "text": "Welcome to the companion website for exploring Sumio Watanabe’s Mathematical Theory of Bayesian Statistics (Singular Learning Theory)."
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Watanabe’s Singular Learning Theory",
    "section": "Contents",
    "text": "Contents\n\nRegular and Singular Models (Reproducing Figures 1.2 to 1.5)\nIllustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model"
  },
  {
    "objectID": "cheat_sheet.html",
    "href": "cheat_sheet.html",
    "title": "Cheat Sheet: Important Definitions",
    "section": "",
    "text": "This page provides a quick reference for the most important definitions in Sumio Watanabe’s Mathematical Theory of Bayesian Statistics and Singular Learning Theory (SLT)."
  },
  {
    "objectID": "cheat_sheet.html#core-concepts",
    "href": "cheat_sheet.html#core-concepts",
    "title": "Cheat Sheet: Important Definitions",
    "section": "Core Concepts",
    "text": "Core Concepts\n\nTrue Distribution\nThe unknown true generation process of the data, denoted \\(q(x)\\).\n\n\nParametric Model\nA set of probability distributions \\(p(x|w)\\) parameterized by \\(w \\in W \\subset \\mathbb{R}^d\\).\n\n\nPrior Distribution\nA probability distribution \\(\\varphi(w)\\) over the parameter space \\(W\\).\n\n\nLog Likelihood Ratio\nThe function that measures the discrepancy between the true distribution and the parametric model: \\[ K(w) = \\int q(x) \\log \\frac{q(x)}{p(x|w)} dx \\] This is the Kullback-Leibler (KL) divergence between \\(q(x)\\) and \\(p(x|w)\\). The set of optimal parameters is \\(W_0 = \\{w \\in W : K(w) = 0 \\}\\)."
  },
  {
    "objectID": "cheat_sheet.html#regular-vs.-singular-models",
    "href": "cheat_sheet.html#regular-vs.-singular-models",
    "title": "Cheat Sheet: Important Definitions",
    "section": "Regular vs. Singular Models",
    "text": "Regular vs. Singular Models\n\nRegular Model\nA statistical model is regular if the map from parameters to probability distributions (\\(w \\mapsto p(x|w)\\)) is one-to-one, and the Fisher information matrix is positive definite at the optimal parameter \\(w_0\\). Regular models satisfy classical asymptotic theories.\n\n\nSingular Model\nA statistical model is singular if it is not regular. In singular models, the Fisher information matrix is singular (not positive definite) at the true parameters, or the parameter-to-distribution mapping is many-to-one. Examples include neural networks, Gaussian mixture models, hidden Markov models, and Bayesian networks."
  },
  {
    "objectID": "cheat_sheet.html#bayesian-inference",
    "href": "cheat_sheet.html#bayesian-inference",
    "title": "Cheat Sheet: Important Definitions",
    "section": "Bayesian Inference",
    "text": "Bayesian Inference\n\nMarginal Likelihood (Evidence)\nThe probability of observing the data \\(X^n = (X_1, \\dots, X_n)\\) given the model and the prior: \\[ Z_n = \\int \\prod_{i=1}^n p(X_i|w) \\varphi(w) dw \\]\n\n\nFree Energy\nThe negative log of the marginal likelihood: \\[ F_n = -\\log Z_n \\] In SLT, the asymptotic behavior of the free energy is a central object of study. For regular models, \\(F_n \\approx n L_n(\\hat{w}) + \\frac{d}{2} \\log n\\). For singular models, it requires algebraic geometry to analyze.\n\n\nPosterior Distribution\nGiven \\(n\\) independent observations \\(X^n = (X_1, \\dots, X_n)\\) from \\(q(x)\\), the posterior is: \\[ p(w|X^n) = \\frac{1}{Z_n} \\prod_{i=1}^n p(X_i|w) \\varphi(w) \\]"
  },
  {
    "objectID": "cheat_sheet.html#singular-learning-theory-slt-quantities",
    "href": "cheat_sheet.html#singular-learning-theory-slt-quantities",
    "title": "Cheat Sheet: Important Definitions",
    "section": "Singular Learning Theory (SLT) Quantities",
    "text": "Singular Learning Theory (SLT) Quantities\n\nReal Log Canonical Threshold (RLCT)\nDenoted as \\(\\lambda\\). A positive rational number that measures the “singularity” of the optimal parameter set \\(W_0\\). It replaces the parameter dimension \\(d/2\\) in the asymptotic expansion of the free energy for singular models. Lower \\(\\lambda\\) implies a more severe singularity and a smaller effective dimension, often leading to better generalization and simpler representations.\n\n\nMultiplicity\nDenoted as \\(m\\). It is the maximum power of the logarithmic term \\(\\log n\\) that appears alongside the RLCT in the asymptotic expansion of the free energy. The asymptotic expansion of the free energy in SLT is: \\[ F_n \\approx n S_n + \\lambda \\log n - (m - 1) \\log \\log \\log Z_n \\text{ (wait, actually } (m-1)\\log\\log n) \\] Wait, the actual formula is \\(F_n \\approx n S_n + \\lambda \\log n - (m - 1) \\log \\log n + O_p(1)\\) where \\(S_n\\) is the empirical entropy. (Let me fix that typo). \\[ F_n \\approx n S_n + \\lambda \\log n - (m - 1) \\log \\log n + O_p(1) \\]\n\n\nResolution of Singularities / Blow-up\nAn algebraic geometry technique used in SLT. A “blow-up” is a coordinate transformation that resolves singularities in the parameter space, transforming the complex geometric structure of \\(K(w) = 0\\) into a simpler form with normal crossings. This analytic continuation allows the asymptotic evaluation of the marginal likelihood integral.\n\n\nZeta Function of Statistical Learning\nAn analytic function of a complex variable \\(z\\) defined as: \\[ \\zeta(z) = \\int K(w)^{-z} \\varphi(w) dw \\] The poles of this zeta function are deeply connected to the RLCT. The largest pole of the zeta function (which is negative) determines the RLCT \\(\\lambda\\).\n\n\nSingular Fluctuation\nThe variance of the log-likelihood ratio across the posterior distribution. In regular models, the singular fluctuation is \\(d/2\\), but in singular models, it varies depending on the geometry of the singularities. It governs the difference between training error and generalization error."
  },
  {
    "objectID": "cheat_sheet.html#information-criteria",
    "href": "cheat_sheet.html#information-criteria",
    "title": "Cheat Sheet: Important Definitions",
    "section": "Information Criteria",
    "text": "Information Criteria\n\nGeneralization Error\nThe expected loss (e.g., KL divergence) when predicting a new, unseen data point using the predictive distribution trained on \\(X^n\\).\n\n\nTraining Error\nThe empirical loss calculated on the training data \\(X^n\\). Training error is typically lower than generalization error.\n\n\nWAIC (Widely Applicable Information Criterion)\nAn estimator of the generalization error that relies on the log-posterior predictive density and the empirical variance of the log-likelihood over the posterior. WAIC is asymptotically equivalent to the cross-validation loss and works well for both regular and singular models.\n\n\nWBIC (Widely Applicable Bayesian Information Criterion)\nAn estimator of the free energy \\(F_n\\) that works for both regular and singular models. It is calculated by taking the average of the log-likelihood over a tempered posterior distribution with inverse temperature \\(\\beta = 1/\\log n\\). It generalizes the Bayesian Information Criterion (BIC)."
  },
  {
    "objectID": "slt_gaussian_mixture.html",
    "href": "slt_gaussian_mixture.html",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "",
    "text": "This document provides a walk-through of Sumio Watanabe’s Singular Learning Theory (up to Chapter 6), using a two-component Gaussian Mixture Model (GMM) as a concrete pedagogical example."
  },
  {
    "objectID": "slt_gaussian_mixture.html#introduction-the-model-and-the-true-distribution-chapter-1",
    "href": "slt_gaussian_mixture.html#introduction-the-model-and-the-true-distribution-chapter-1",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "1. Introduction: The Model and the True Distribution (Chapter 1)",
    "text": "1. Introduction: The Model and the True Distribution (Chapter 1)\nIn statistical formulation, we consider a learning machine defined by a parametric statistical model \\(p(x|w)\\) and a true data-generating distribution \\(q(x)\\).\n\nThe Two-Component Gaussian Mixture\nLet’s define a simple 2-parameter Gaussian Mixture Model where one component is fixed at the origin: \\[ p(x|w) = (1-a) \\mathcal{N}(x|0, 1) + a \\mathcal{N}(x|\\mu, 1) \\] Here, the parameter vector is \\(w = (a, \\mu) \\in W = [0, 1] \\times [-c, c]\\).\nSuppose the true distribution is simply a standard normal distribution: \\[ q(x) = \\mathcal{N}(x|0, 1) \\]\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-4, 4, 400)\nq = np.exp(-x**2/2)/np.sqrt(2*np.pi)\np = 0.7 * np.exp(-x**2/2)/np.sqrt(2*np.pi) + 0.3 * np.exp(-(x-1.5)**2/2)/np.sqrt(2*np.pi)\n\nplt.figure(figsize=(8, 5))\nplt.plot(x, q, label=r'True Distribution $q(x) = \\mathcal{N}(0,1)$', color='blue', linewidth=2)\nplt.plot(x, p, label=r'Model $p(x|w)$ with $a=0.3, \\mu=1.5$', color='red', linestyle='--')\nplt.title(\"Gaussian Mixture Model vs True Distribution\")\nplt.xlabel(\"x\")\nplt.ylabel(\"Density\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: True Distribution vs Model\n\n\n\n\n\n\n\nThe Set of True Parameters\nThe true distribution is realized by the model whenever \\(p(x|w) = q(x)\\). By inspecting the equation: \\[ (1-a) \\mathcal{N}(x|0, 1) + a \\mathcal{N}(x|\\mu, 1) = \\mathcal{N}(x|0, 1) \\] \\[ a (\\mathcal{N}(x|\\mu, 1) - \\mathcal{N}(x|0, 1)) = 0 \\]\nThis holds true if and only if \\(a = 0\\) (the mixing proportion is zero) OR \\(\\mu = 0\\) (both components are identical). Thus, the set of true parameters \\(W_0\\) is: \\[ W_0 = \\{ (a, \\mu) \\in W : a = 0 \\text{ or } \\mu = 0 \\} \\]\nThis means that \\(W_0\\) is not a single point, but the union of two intersecting lines. In classical (regular) statistical theory, \\(W_0\\) is assumed to be a single point, and the Fisher Information Matrix is positive definite. Here, the Fisher Information Matrix degenerates on \\(W_0\\), making this a singular model.\n\n\nThe Kullback-Leibler Divergence\nThe log-likelihood ratio (empirical loss) is driven by the Kullback-Leibler (KL) divergence from \\(q(x)\\) to \\(p(x|w)\\): \\[ K(w) = \\int q(x) \\log \\frac{q(x)}{p(x|w)} dx \\]\nUsing a Taylor expansion for small \\(a\\) and \\(\\mu\\), we can approximate \\(p(x|w)\\): \\[ p(x|w) = \\mathcal{N}(x|0, 1) \\left[ 1 + a (e^{\\mu x - \\mu^2/2} - 1) \\right] \\approx \\mathcal{N}(x|0, 1) \\left[ 1 + a\\left(\\mu x + \\frac{1}{2}\\mu^2(x^2 - 1)\\right) \\right] \\]\nPlugging this into the KL divergence and using \\(-\\log(1+z) \\approx -z + z^2/2\\), the linear terms integrate to 0 under \\(q(x)\\), leaving the leading non-zero term: \\[ K(w) \\approx \\frac{1}{2} a^2 \\mu^2 \\]\n\n\nCode\nA = np.linspace(-1, 1, 400)\nM = np.linspace(-2, 2, 400)\nAA, MM = np.meshgrid(A, M)\nK = 0.5 * (AA**2) * (MM**2)\n\nplt.figure(figsize=(8, 6))\ncontour = plt.contourf(AA, MM, K, levels=20, cmap='viridis_r')\nplt.colorbar(contour, label=r'KL Divergence $K(a, \\mu)$')\nplt.axhline(0, color='red', linewidth=3, label='True Parameters ($a=0$)')\nplt.axvline(0, color='red', linewidth=3, label=r'True Parameters ($\\mu=0$)')\nplt.title(\"Parameter Space and KL Divergence\")\nplt.xlabel(\"Parameter $a$\")\nplt.ylabel(r\"Parameter $\\mu$\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2: Parameter Space and KL Divergence. Notice how the valley of \\(K(w)=0\\) forms a cross at \\(a=0\\) and \\(\\mu=0\\)."
  },
  {
    "objectID": "slt_gaussian_mixture.html#resolution-of-singularities-chapter-2",
    "href": "slt_gaussian_mixture.html#resolution-of-singularities-chapter-2",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "2. Resolution of Singularities (Chapter 2)",
    "text": "2. Resolution of Singularities (Chapter 2)\nBecause the set of true parameters \\(W_0\\) has a singularity (an intersection forming a cross), standard asymptotic expansions (like the Laplace approximation) fail. Watanabe employs Hironaka’s Theorem on the Resolution of Singularities from algebraic geometry to resolve this.\nThe theorem states that there exists a real analytic manifold \\(\\mathcal{M}\\) and a proper analytic map \\(g: \\mathcal{M} \\to W\\) (a “blow-up”) such that the composition \\(K(g(u))\\) has a simple normal crossing form.\n\nThe Blow-Up Transformation\nFor the approximation \\(K(w) \\approx \\frac{1}{2} a^2 \\mu^2\\), the true parameters \\(W_0\\) correspond to the crossing lines \\(a=0\\) and \\(\\mu=0\\). To resolve this intersection, we apply a “blow-up” transformation. A blow-up geometrically replaces the problematic intersection point (the origin) with an entire line (called the exceptional divisor), separating the paths that cross there.\nWe can reparameterize the space by keeping track of the slope of lines passing through the origin. We define a local coordinate chart (a directional blow-up) as: \\[ a = u_1 \\] \\[ \\mu = u_1 u_2 \\]\nHere, \\(u_1\\) simply represents the original \\(a\\) coordinate, while \\(u_2 = \\mu / a\\) represents the slope of a line passing through the origin in the \\((a, \\mu)\\) parameter space.\n\nA single point in the original space—the origin \\((a=0, \\mu=0)\\)—now corresponds to the entire line \\(u_1 = 0\\) for any value of \\(u_2\\) in the new space.\nThe crossing lines in the \\((a, \\mu)\\) space have been pulled apart. Actually, our new coordinate system does not extend to the line \\(a=0\\), but we can get arbitrarily close to it. We would need another patch with coordinates \\(\\mu, a/\\mu\\) to represent the line \\(a=0\\).\n\nThe KL divergence in these new coordinates \\(u = (u_1, u_2)\\) is \\[ K(g(u)) \\approx \\frac{1}{2} (u_1)^2 (u_1 u_2)^2 = \\frac{1}{2} u_1^4 u_2^2 \\]\nWe must also account for the distortion of the volume measure, dictated by the Jacobian of \\(g\\): \\[ dw = |g'(u)| du = \\left| \\det \\begin{pmatrix} 1 & 0 \\\\ u_2 & u_1 \\end{pmatrix} \\right| du_1 du_2 = |u_1| du_1 du_2 \\]"
  },
  {
    "objectID": "slt_gaussian_mixture.html#standard-form-and-real-log-canonical-threshold-chapter-3",
    "href": "slt_gaussian_mixture.html#standard-form-and-real-log-canonical-threshold-chapter-3",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "3. Standard Form and Real Log Canonical Threshold (Chapter 3)",
    "text": "3. Standard Form and Real Log Canonical Threshold (Chapter 3)\nIn Chapter 3, Watanabe introduces the concept of the Real Log Canonical Threshold (RLCT), denoted by \\(\\lambda\\), and its multiplicity \\(m\\). These two algebraic invariants completely govern the asymptotic behavior of the learning machine.\nTo understand why the blow-up was a strictly necessary algebraic maneuver, we have to look at how \\(\\lambda\\) is formally calculated. By definition, the RLCT is found by examining the analytic continuation of the zeta function of the statistical model, given by the integral: \\[ \\zeta(z) = \\int (K(w))^z \\varphi(w) dw \\] where \\(\\varphi(w)\\) is the prior distribution and \\(z \\in \\mathbb{C}\\) (\\(\\Re(z) &gt; 0\\)). The RLCT \\(\\lambda\\) is defined such that \\(-\\lambda\\) is the largest (closest to zero) real pole of this function, and its multiplicity \\(m\\) is the order of this pole.\nWithout the blow-up, evaluating this integral and finding its poles is mathematically intractable. The true KL divergence \\(K(w)\\) isn’t just a simple polynomial like \\(a^2\\mu^2\\); it contains an infinite series of higher-order terms from the Taylor expansion. Because the variables are coupled in a highly non-linear way at the singularity (the cross \\(a=0, \\mu=0\\)), you cannot separate the variables to evaluate the integral.\nThis is where the blow-up of the singularity resolves the integration problem. Hironaka’s Theorem guarantees that after passing to the resolved coordinates \\(u\\), the fully complex divergence \\(K(g(u))\\) perfectly factors into a single monomial multiplied by a non-vanishing positive analytic function \\(b(u) &gt; 0\\). The prior measure and Jacobian of the blow-up also become a simple monomial multiplied by a strictly positive function \\(c(u) &gt; 0\\).\nWhen we substitute this Standard Form into the zeta function integral using our resolved coordinates \\(u\\), the variables completely decouple near the origin: \\[ \\zeta(z) = \\int \\left( u_1^{2k_{1}} u_2^{2k_{2}} b(u) \\right)^z \\left( u_1^{h_1} u_2^{h_2} c(u) \\right) du_1 du_2 \\] \\[ \\zeta(z) \\approx C \\left( \\int u_1^{2k_1 z + h_1} du_1 \\right) \\left( \\int u_2^{2k_2 z + h_2} du_2 \\right) \\]\nEvaluating these independent 1D integrals yields formulas of the type: \\[ \\int_0^\\epsilon u^{2k z + h} du = \\frac{\\epsilon^{2k z + h + 1}}{2k z + h + 1} \\] This expression clearly has a pole exactly when the denominator is zero, i.e., at \\(z = -\\frac{h + 1}{2k}\\).\nBy separating the variables, the blow-up perfectly isolates the poles of the zeta function!\nUsing our specific factors from the GMM blow-up: 1. Divergence function: \\(K(u) = u_1^4 u_2^2\\) (so \\(k_1 = 2\\), \\(k_2 = 1\\)) 2. Prior measure / Jacobian: \\(\\Phi(u) = u_1^1 u_2^0\\) (so \\(h_1 = 1\\), \\(h_2 = 0\\))\nThe candidate poles \\(z = -\\lambda_j\\) along each coordinate axis \\(j\\) give us: \\[ \\lambda_j = \\frac{h_j + 1}{2k_j} \\]\nFor our \\(u_1\\) and \\(u_2\\): - \\(\\lambda_1 = \\frac{1 + 1}{4} = \\frac{1}{2}\\) - \\(\\lambda_2 = \\frac{0 + 1}{2} = \\frac{1}{2}\\)\nThe overall RLCT \\(\\lambda\\) is dictated by the pole closest to zero, which is the minimum of these values: \\[ \\lambda = \\min(\\lambda_1, \\lambda_2) = \\min(1/2, 1/2) = \\frac{1}{2} \\]\nThe multiplicity \\(m\\) is the order of this leading pole, which equals the number of coordinate indices \\(j\\) that achieve this minimum. Here, both \\(\\lambda_1\\) and \\(\\lambda_2\\) equal \\(1/2\\). Thus: \\[ m = 2 \\]\nNote: In a regular model with parameter dimension \\(d=2\\), the RLCT is always \\(\\lambda = d/2 = 1\\). Our singular GMM has \\(\\lambda = 1/2 &lt; 1\\), showcasing the mathematical definition of a singular learning machine."
  },
  {
    "objectID": "slt_gaussian_mixture.html#singular-fluctuation-and-free-energy-chapter-4",
    "href": "slt_gaussian_mixture.html#singular-fluctuation-and-free-energy-chapter-4",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "4. Singular Fluctuation and Free Energy (Chapter 4)",
    "text": "4. Singular Fluctuation and Free Energy (Chapter 4)\nIn Bayesian evaluation, the Stochastic Complexity or Free Energy \\(F_n\\) represents the negative log-marginal likelihood (evidence) of the data \\(X^n\\): \\[ F_n = -\\log Z_n = -\\log \\int e^{-n L_n(w)} \\varphi(w) dw \\] where \\(L_n(w) = -\\frac{1}{n} \\sum \\log p(X_i|w)\\) is the empirical loss.\nChapter 4 defines how the parameter posterior behaves under singular fluctuations. Using the algebraic invariants we just found, SLT proves that the free energy asymptotically expands as:\n\\[ F_n \\approx n L_n(w_0) + \\lambda \\log n - (m-1) \\log \\log n + O_p(1) \\]\nFor our two-component Gaussian Mixture Model: \\[ F_n \\approx n L_n(w_0) + \\frac{1}{2} \\log n - \\log \\log n + O_p(1) \\]\n\n\nCode\nn = np.logspace(1, 4, 100)\nF_reg = 1.0 * np.log(n)\nF_sing = 0.5 * np.log(n) - 1.0 * np.log(np.log(n + 1.1))\n\nplt.figure(figsize=(8, 5))\nplt.plot(n, F_reg, label=r'Regular Model ($d=2 \\Rightarrow \\lambda=1$)', color='red')\nplt.plot(n, F_sing, label=r'Singular Model (GMM, $\\lambda=0.5, m=2$)', color='blue')\nplt.title(\"Asymptotic Free Energy Penalty vs Sample Size\")\nplt.xlabel(\"Sample Size $n$ (log scale)\")\nplt.ylabel(\"Penalty Term\")\nplt.xscale('log')\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 3: Asymptotic Free Energy. The penalty term for the singular model is significantly smaller than for a regular model, making singular models heavily preferred by the marginal likelihood.\n\n\n\n\n\nThis result breaks the classical Bayesian Information Criterion (BIC), which assumes a penalty of \\(\\frac{d}{2} \\log n\\). BIC would have penalized this 2-parameter model by \\(1.0 \\log n\\), entirely missing the true Bayesian Occam’s Razor effect on the singular manifold."
  },
  {
    "objectID": "slt_gaussian_mixture.html#generalization-and-training-errors-chapter-5",
    "href": "slt_gaussian_mixture.html#generalization-and-training-errors-chapter-5",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "5. Generalization and Training Errors (Chapter 5)",
    "text": "5. Generalization and Training Errors (Chapter 5)\nChapter 5 links the geometry of the parameter space to the average errors. Let \\(G_n\\) be the Generalization Error (expected loss on new data) and \\(T_n\\) be the Training Error (empirical loss on the training set).\nIn traditional regular statistics (like AIC), the expectation of these errors relies on \\(d\\): \\[ \\mathbb{E}[G_n] = L(w_0) + \\frac{d}{2n} \\] \\[ \\mathbb{E}[T_n] = L(w_0) - \\frac{d}{2n} \\]\nIn Singular Learning Theory, Watanabe elegantly proves a symmetry relation using \\(\\lambda\\): \\[ \\mathbb{E}[G_n] = L(w_0) + \\frac{\\lambda}{n} \\] \\[ \\mathbb{E}[T_n] = L(w_0) - \\frac{\\lambda}{n} \\]\nFor our continuous GMM, \\(\\lambda = 1/2\\). Therefore: - Expected Generalization Error converges with rate \\(\\frac{0.5}{n}\\). - Expected Training Error converges with rate \\(-\\frac{0.5}{n}\\).\nThis explains why heavily overparameterized singular models (like deep neural networks and complex mixtures) often generalize better than their parameter count \\(d\\) would imply; their learning dynamics are constrained by the smaller geometric invariant \\(\\lambda &lt; d/2\\)."
  },
  {
    "objectID": "slt_gaussian_mixture.html#asymptotic-expansion-and-waic-chapter-6",
    "href": "slt_gaussian_mixture.html#asymptotic-expansion-and-waic-chapter-6",
    "title": "Illustrating Watanabe’s Singular Learning Theory with a Gaussian Mixture Model",
    "section": "6. Asymptotic Expansion and WAIC (Chapter 6)",
    "text": "6. Asymptotic Expansion and WAIC (Chapter 6)\nFinally, Chapter 6 resolves a crucial practical problem. Since calculating \\(\\lambda\\) analytically requires algebraic blow-ups (which is impossible for massive modern models like LLMs), we cannot use it directly to estimate the generalization error. Furthermore, cross-validation can be unstable in singular models.\nWatanabe introduces the Widely Applicable Information Criterion (WAIC): \\[ \\text{WAIC} = T_n + \\frac{1}{n} \\sum_{i=1}^n V_w \\left( \\log p(X_i | w) \\right) \\] Where \\(V_w\\) is the posterior variance of the log-likelihood for data point \\(X_i\\).\nThe core theorem of Chapter 6 proves that WAIC is an asymptotically unbiased estimator of the generalization error, even for singular models: \\[ \\mathbb{E}[\\text{WAIC}] \\approx \\mathbb{E}[G_n] \\]\nIn the context of our GMM, evaluating the posterior variance computationally via Markov Chain Monte Carlo (MCMC) allows us to estimate the true hold-out performance without needing to analytically find \\(\\lambda = 1/2\\) or \\(m=2\\), proving WAIC’s universal applicability in modern deep learning and mixture modeling.\n\nCalculating WAIC in Practice\nTo make this concrete, let’s generate a synthetic dataset from the true distribution \\(q(x) = \\mathcal{N}(0, 1)\\) and compute the WAIC for our toy GMM. By using a fine grid covering our parameter space \\(W = [0, 1] \\times [-2, 2]\\), we can exactly compute the posterior and WAIC without relying on intricate MCMC setups.\n\n\nCode\nimport numpy as np\n\n# 1. Generate synthetic data from true distribution q(x) = N(0,1)\nnp.random.seed(42)\nn = 100\nX = np.random.normal(0, 1, n)\n\n# 2. Define parameter grid for evaluating the posterior\na_vals = np.linspace(0, 1, 100)\nmu_vals = np.linspace(-2, 2, 100)\nA, MU = np.meshgrid(a_vals, mu_vals)\n\n# p(x|a, mu) = (1-a)*N(x|0,1) + a*N(x|mu,1)\ndef norm_pdf(x, m, s):\n    return np.exp(-0.5 * ((x - m) / s)**2) / (np.sqrt(2 * np.pi) * s)\n\n# 3. Compute log-likelihood for each parameter pair and each data point\nlog_p = np.zeros((n, len(mu_vals), len(a_vals)))\nfor i, x in enumerate(X):\n    p_x_w = (1 - A) * norm_pdf(x, 0, 1) + A * norm_pdf(x, MU, 1)\n    # Add a small epsilon to prevent log(0)\n    log_p[i] = np.log(p_x_w + 1e-12)\n\n# 4. Compute unnormalized posterior probabilities (assuming uniform prior)\n# Sum over all data points to get the full log-likelihood for each parameter pair\ntotal_log_likelihood = np.sum(log_p, axis=0) \n# Subtract maximum for numerical stability before exponentiating\nlog_posterior = total_log_likelihood - np.max(total_log_likelihood)\nposterior = np.exp(log_posterior)\n# Normalize to create a valid probability distribution over the grid\nposterior /= np.sum(posterior) \n\n# 5. Calculate WAIC\npredictive_density = np.zeros(n)\nV_w = np.zeros(n)\n\nfor i in range(n):\n    # Expected volume: E_w[p(X_i|w)]\n    predictive_density[i] = np.sum(np.exp(log_p[i]) * posterior)\n    \n    # Posterior variance of the log-likelihood: V_w(log p(X_i|w))\n    expected_log_p = np.sum(log_p[i] * posterior)\n    expected_log_p_sq = np.sum((log_p[i]**2) * posterior)\n    V_w[i] = expected_log_p_sq - expected_log_p**2\n\n# T_n: Empirical training loss of the Bayes predictive distribution\nT_n = -1.0 / n * np.sum(np.log(predictive_density + 1e-12))\n\n# Functional variance penalty term\n# This corresponds to (1/n) * sum(V_w)\npenalty = np.mean(V_w)\n\nwaic = T_n + penalty\n\n# 6. Calculate True Generalization Error on massive holdout\nn_test = 20000\nX_test = np.random.normal(0, 1, n_test)\n\npred_dens_test = np.zeros(n_test)\nbatch_size = 2000\nfor b in range(0, n_test, batch_size):\n    end_idx = min(b + batch_size, n_test)\n    X_batch = X_test[b:end_idx]\n    X_expanded = X_batch[:, np.newaxis, np.newaxis]\n    p_batch = (1 - A) * norm_pdf(X_expanded, 0, 1) + A * norm_pdf(X_expanded, MU, 1)\n    expected_p = np.sum(p_batch * posterior, axis=(1, 2))\n    pred_dens_test[b:end_idx] = expected_p\n\ngen_error = -1.0 / n_test * np.sum(np.log(pred_dens_test + 1e-12))\n\nprint(f\"Sample size n = {n}\")\nprint(f\"Training Error (T_n) = {T_n:.4f}\")\nprint(f\"Penalty Term (V / n) = {penalty:.4f}\")\nprint(f\"WAIC = {waic:.4f}\")\nprint(f\"Generalization Error = {gen_error:.4f}\")\n\n\nSample size n = 100\nTraining Error (T_n) = 1.3310\nPenalty Term (V / n) = 0.0057\nWAIC = 1.3367\nGeneralization Error = 1.4243\n\n\n\n\nVisualizing the Posterior\nWe can also visualize the posterior distribution over our parameter grid to see how it concentrates around the true parameters. Because this is a singular model, the asymptotic distribution does not look like a neat Gaussian blob—instead, it concentrates along the non-identifiable manifold (the cross at \\(a=0\\) or \\(\\mu=0\\)).\n\n\nCode\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8, 6))\ncontour = plt.contourf(A, MU, posterior, levels=20, cmap='viridis')\nplt.colorbar(contour, label='Posterior Probability')\nplt.axhline(0, color='red', linestyle='--', alpha=0.5, label='True Parameters ($a=0$)')\nplt.axvline(0, color='red', linestyle='--', alpha=0.5, label=r'True Parameters ($\\mu=0$)')\nplt.title(\"Posterior Distribution of GMM Parameters\")\nplt.xlabel(\"Parameter $a$\")\nplt.ylabel(r\"Parameter $\\mu$\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure 4: Posterior Distribution of GMM Parameters. Notice how the probability mass is drawn out along the axes representing the true parameters.\n\n\n\n\n\n\n\nContrast: Asymptotic Regularity vs. Finite-Sample Singularity\nWhat happens if the true distribution \\(q(x)\\) is actually drawn from a genuine two-component mixture with both \\(a \\neq 0\\) and \\(\\mu \\neq 0\\)? For example, setting \\(a=0.5\\) and \\(\\mu=0.3\\).\nIn this case, the true parameters \\((a_0, \\mu_0)\\) lie in the interior of the parameter space, and there is exactly one parameter combination that matches the distribution. The true parameter space shrinks to a single, unique point. Because the true parameters are uniquely identifiable, the log-likelihood function has a strict minimum at \\((a_0, \\mu_0)\\), and the Hessian (Fisher Information Matrix) becomes positive definite. Asymptotically (\\(n \\to \\infty\\)), the model behaves as a standard regular model.\nIn this theoretical asymptotic scenario: 1. The Real Log Canonical Threshold becomes \\(\\lambda = d/2 = 2/2 = 1.0\\). 2. The multiplicity is \\(m = 1\\). 3. The Bayesian Occam’s Razor penalty term in WAIC should converge to roughly \\(1.0\\times (\\log n)/n\\) for free energy, or \\(1.0/n\\) for generalization error. We expect the functional variance \\(V\\) to approximate this \\(1.0\\) factor (rather than \\(0.5\\)).\nLet’s test this by running our WAIC code again, but generating the data from \\(a=0.5\\) and \\(\\mu=0.3\\):\n\n\nCode\n# 1. Generate synthetic data from a true mixture model\nnp.random.seed(42)\nn_reg = 100\na_true = 0.5\nmu_true = 0.3\n\nz = np.random.binomial(1, a_true, n_reg)\nX_reg = np.zeros(n_reg)\nX_reg[z == 0] = np.random.normal(0, 1, np.sum(z == 0))\nX_reg[z == 1] = np.random.normal(mu_true, 1, np.sum(z == 1))\n\n# 2. Compute log-likelihood\nlog_p_reg = np.zeros((n_reg, len(mu_vals), len(a_vals)))\nfor i, x in enumerate(X_reg):\n    p_x_w = (1 - A) * norm_pdf(x, 0, 1) + A * norm_pdf(x, MU, 1)\n    log_p_reg[i] = np.log(p_x_w + 1e-12)\n\n# 3. Compute posterior\ntotal_log_likelihood_reg = np.sum(log_p_reg, axis=0) \nlog_posterior_reg = total_log_likelihood_reg - np.max(total_log_likelihood_reg)\nposterior_reg = np.exp(log_posterior_reg)\nposterior_reg /= np.sum(posterior_reg) \n\n# 4. Calculate WAIC penalty\npredictive_density_reg = np.zeros(n_reg)\nV_w_reg = np.zeros(n_reg)\nfor i in range(n_reg):\n    predictive_density_reg[i] = np.sum(np.exp(log_p_reg[i]) * posterior_reg)\n    expected_log_p = np.sum(log_p_reg[i] * posterior_reg)\n    expected_log_p_sq = np.sum((log_p_reg[i]**2) * posterior_reg)\n    V_w_reg[i] = expected_log_p_sq - expected_log_p**2\n\nT_n_reg = -1.0 / n_reg * np.sum(np.log(predictive_density_reg + 1e-12))\npenalty_reg = np.mean(V_w_reg)\nwaic_reg = T_n_reg + penalty_reg\n\n# 5. Calculate True Generalization Error\nn_test = 20000\nz_test = np.random.binomial(1, a_true, n_test)\nX_test_reg = np.zeros(n_test)\nX_test_reg[z_test == 0] = np.random.normal(0, 1, np.sum(z_test == 0))\nX_test_reg[z_test == 1] = np.random.normal(mu_true, 1, np.sum(z_test == 1))\n\npred_dens_test_reg = np.zeros(n_test)\nbatch_size = 2000\nfor b in range(0, n_test, batch_size):\n    end_idx = min(b + batch_size, n_test)\n    X_batch = X_test_reg[b:end_idx]\n    X_expanded = X_batch[:, np.newaxis, np.newaxis]\n    p_batch = (1 - A) * norm_pdf(X_expanded, 0, 1) + A * norm_pdf(X_expanded, MU, 1)\n    expected_p = np.sum(p_batch * posterior_reg, axis=(1, 2))\n    pred_dens_test_reg[b:end_idx] = expected_p\n\ngen_error_reg = -1.0 / n_test * np.sum(np.log(pred_dens_test_reg + 1e-12))\n\nprint(f\"Sample size n = {n_reg}\")\nprint(f\"Training Error (T_n) = {T_n_reg:.4f}\")\nprint(f\"Regular Penalty Term (V / n) = {penalty_reg:.4f}\")\nprint(f\"WAIC = {waic_reg:.4f}\")\nprint(f\"Generalization Error = {gen_error_reg:.4f}\")\n\n# 6. Plot the new regular posterior\nplt.figure(figsize=(7, 5))\ncontour3 = plt.contourf(A, MU, posterior_reg, levels=20, cmap='viridis')\nplt.colorbar(contour3, label='Posterior Probability')\nplt.scatter([a_true], [mu_true], color='red', marker='x', s=100, linewidths=3, label='True Parameters')\nplt.title(\"Posterior Distribution (Regular Model)\")\nplt.xlabel(\"Parameter $a$\")\nplt.ylabel(r\"Parameter $\\mu$\")\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\nSample size n = 100\nTraining Error (T_n) = 1.3483\nRegular Penalty Term (V / n) = 0.0073\nWAIC = 1.3556\nGeneralization Error = 1.4317\n\n\n\n\n\nPosterior Distribution for the ‘Regular’ Case with Finite Sample Size. Because the true parameter \\(\\mu=0.3\\) is very close to the singularity \\(\\mu=0\\), the sample size \\(n=100\\) is not large enough to resolve the parameters perfectly. The posterior is gravitationally pulled into the singularity, maintaining the shape and WAIC penalty of a singular model.\n\n\n\n\n\nThe Gravitational Pull of the Singularity\nNotice what happened in the plot and output! Despite the true model being theoretically regular, the penalty term \\(V \\approx 0.73\\) is far closer to the singular penalty \\(0.5\\) than the regular penalty \\(1.0\\). And the posterior clearly does not look like a neat Gaussian blob; it is smeared out along the \\(\\mu=0\\) axis exactly like the singular case.\nWhy? Because the true parameter \\(\\mu=0.3\\) is extremely close to the singular manifold (\\(\\mu=0\\)). Watanabe’s theory is asymptotic (\\(n \\to \\infty\\)). For a finite sample size of \\(n=100\\), the data simply does not have enough resolution to confidently distinguish the true distribution \\(\\mu=0.3\\) from the singularity at \\(\\mu=0\\). The likelihood spills over into the singularity, and the posterior is “gravitationally pulled” into the non-identifiable manifold, forcing the model to behave like a singular machine. It would take a much larger sample size (e.g., \\(n=10,000\\)) for the regular asymptotic theory to overcome the geometry of the singularity locally.\nThis is a profound realization from Singular Learning Theory: singularities govern the learning dynamics of models in practice, even when the true distribution is slightly off the singularity, because finite samples cannot perfectly resolve the identifiability.\nThe mathematical beauty of Chapter 6 is that WAIC works uniformly in both these cases without adjustment. The functional variance inherently adapts to the finite-sample geometry of the posterior, providing an accurate estimator of the true generalization error regardless of whether the model is trapped in a singularity or has broken free!\n\n\n\nIs WAIC Still Good for Small Samples?\nA natural follow-up question is whether WAIC remains a good estimator of generalization error when the sample size \\(n\\) is very small. The short answer is yes, and this is exactly where WAIC shines compared to classical criteria like the Deviance Information Criterion (DIC).\nClassical criteria like DIC rely on a point estimate of the parameter (usually the posterior mean or mode). In a singular model, the posterior is highly non-Gaussian and often stretched along a non-identifiable manifold (like the cross at \\(\\mu=0\\) or \\(a=0\\)). For a small sample, the posterior mean might land in a region of very low actual probability mass (e.g., in the empty space between two dense arms of the posterior). Because DIC evaluates the likelihood at this single mathematically awkward point, it can wildly misestimate the generalization error.\nWAIC, on the other hand, averages the likelihood over the entire posterior distribution and calculates the functional variance point-by-point. It entirely avoids point estimation."
  },
  {
    "objectID": "regular_and_singular_models.html",
    "href": "regular_and_singular_models.html",
    "title": "Regular and Singular Models",
    "section": "",
    "text": "This document reproduces Figures 1.2 to 1.5 from Sumio Watanabe’s Mathematical Theory of Bayesian Statistics, demonstrating the fundamental differences between regular and singular statistical models."
  },
  {
    "objectID": "regular_and_singular_models.html#overview",
    "href": "regular_and_singular_models.html#overview",
    "title": "Regular and Singular Models",
    "section": "Overview",
    "text": "Overview\nIn Bayesian statistics, we observe how the posterior distribution behaves as the sample size \\(n\\) increases.\n\nRegular Models: Provide a one-to-one mapping from parameters to probability distributions with a strictly positive-definite Fisher information matrix. By the Bernstein-von Mises theorem, the posterior distribution asymptotically approaches a normal distribution, regardless of the specific sample realization.\nSingular Models: Feature unidentifiable parameters or a degenerate Fisher information matrix. The posterior distribution does not converge to a normal distribution, regardless of sample size, and its shape varies wildly depending on the specific realization of the data.\n\nWe generate multiple datasets for different sample sizes to visualize these properties."
  },
  {
    "objectID": "regular_and_singular_models.html#model-1-a-regular-statistical-model",
    "href": "regular_and_singular_models.html#model-1-a-regular-statistical-model",
    "title": "Regular and Singular Models",
    "section": "Model 1: A Regular Statistical Model",
    "text": "Model 1: A Regular Statistical Model\nIn our first model (Eq. 1.11), the data is drawn from a standard normal distribution \\(\\mathcal{N}(0, 1)\\). We model this with a normal distribution with an unknown mean \\(a\\) and standard deviation \\(\\sigma\\). \\[p(x \\mid a, \\sigma) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - a)^2}{2\\sigma^2}\\right)\\] The true parameters are \\(a = 0\\) and \\(\\sigma = 1\\). The Fisher Information Matrix at the true parameters is positive definite, making this a regular model.\nLet’s define the functions to generate data and plot the posterior distribution.\n\n\nCode\ndef generate_data_model1(n, num_datasets=12, seed=42):\n    np.random.seed(seed)\n    return np.random.normal(loc=0.0, scale=1.0, size=(num_datasets, n))\n\ndef posterior_model1(x, a_range, sigma_range):\n    A, Sigma = np.meshgrid(a_range, sigma_range)\n    x_reshaped = x.reshape(-1, 1, 1)\n    log_likelihood_all = -0.5 * np.log(2 * np.pi * Sigma**2) - 0.5 * ((x_reshaped - A) / Sigma)**2\n    log_likelihood = np.sum(log_likelihood_all, axis=0)\n    \n    log_posterior = log_likelihood - np.max(log_likelihood)\n    posterior = np.exp(log_posterior)\n    posterior /= np.sum(posterior)\n    return A, Sigma, posterior\n\ndef plot_model1(n, num_datasets=12):\n    data = generate_data_model1(n, num_datasets, seed=n)\n    a_vals = np.linspace(-1, 1, 100)\n    sigma_vals = np.linspace(0.01, 2.0, 100)\n    \n    fig, axes = plt.subplots(3, 4, figsize=(10, 7), sharex=True, sharey=True)\n    fig.subplots_adjust(wspace=0.1, hspace=0.1)\n    \n    for i in range(num_datasets):\n        ax = axes[i // 4, i % 4]\n        A, Sigma, post = posterior_model1(data[i], a_vals, sigma_vals)\n        ax.imshow(post, origin='lower', extent=[-1, 1, 0.01, 2.0], aspect='auto', cmap='gray_r')\n        ax.plot(0, 1, 'ws', markersize=6, markeredgecolor='k')\n        \n        ax.set_xticks([-1, 0, 1])\n        ax.set_yticks([0, 1, 2])\n        if i // 4 == 2:\n            ax.set_xlabel('a')\n        if i % 4 == 0:\n            ax.set_ylabel(r'$\\sigma$')\n            \n    plt.show()\n\n\n\nReproducing Figure 1.2 (\\(n = 10\\))\nHere we visualize the posterior distribution for 12 different generated datasets, each with \\(n=10\\) observations. The true parameter value \\((a=0, \\sigma=1)\\) is indicated by the white square. With a small sample size, the posteriors are broad and slightly irregular, heavily influenced by the specific data samples.\n\n\nCode\nplot_model1(10)\n\n\n\n\n\n\n\n\n\n\n\nReproducing Figure 1.3 (\\(n = 50\\))\nWhen we increase the sample size to \\(n=50\\), two things happen: 1. The posterior probability mass tightly concentrates around the true parameter \\((0, 1)\\). 2. The shape of the posterior takes on a consistent, isotropic ‘blob’ (a Gaussian profile), independent of the precise sampling variations. This is a hallmark of regular models.\n\n\nCode\nplot_model1(50)"
  },
  {
    "objectID": "regular_and_singular_models.html#model-2-a-singular-statistical-model",
    "href": "regular_and_singular_models.html#model-2-a-singular-statistical-model",
    "title": "Regular and Singular Models",
    "section": "Model 2: A Singular Statistical Model",
    "text": "Model 2: A Singular Statistical Model\nOur second model (Eq. 1.12) fits a two-component Gaussian mixture to data. The data is generated as a 50/50 mix of \\(\\mathcal{N}(0, 1)\\) and \\(\\mathcal{N}(0.3, 1)\\). Our model tries to learn the mixture proportions and the mean of the second component: \\[p(x \\mid a, b) = (1 - a) \\mathcal{N}(x \\mid 0, 1) + a \\mathcal{N}(x \\mid b, 1)\\]\nThe true distribution represents \\(a = 0.5\\) and \\(b = 0.3\\). This model is singular. The mapping from parameters to distribution is not identifiable or one-to-one at certain limits, and the Fisher information matrix rank decreases at these singularities. Consequently, standard statistical theory (like AIC or the Laplace approximation) fails because the posterior is not normally distributed.\n\n\nCode\ndef generate_data_model2(n, num_datasets=12, seed=42):\n    np.random.seed(seed)\n    data = []\n    for _ in range(num_datasets):\n        components = np.random.choice([0, 1], size=n, p=[0.5, 0.5])\n        means = np.where(components == 0, 0.0, 0.3)\n        sample = np.random.normal(loc=means, scale=1.0)\n        data.append(sample)\n    return np.array(data)\n\ndef posterior_model2(x, a_range, b_range):\n    A, B = np.meshgrid(a_range, b_range)\n    x_reshaped = x.reshape(-1, 1, 1)\n    p1 = np.exp(-0.5 * x_reshaped**2) / np.sqrt(2 * np.pi)\n    p2 = np.exp(-0.5 * (x_reshaped - B)**2) / np.sqrt(2 * np.pi)\n    px = (1 - A) * p1 + A * p2\n    log_likelihood = np.sum(np.log(px + 1e-15), axis=0)\n        \n    log_posterior = log_likelihood - np.max(log_likelihood)\n    posterior = np.exp(log_posterior)\n    posterior /= np.sum(posterior)\n    return A, B, posterior\n\ndef plot_model2(n, num_datasets=12):\n    data = generate_data_model2(n, num_datasets, seed=n)\n    a_vals = np.linspace(0.01, 0.99, 100)\n    b_vals = np.linspace(0.01, 0.99, 100)\n    \n    fig, axes = plt.subplots(3, 4, figsize=(10, 7), sharex=True, sharey=True)\n    fig.subplots_adjust(wspace=0.1, hspace=0.1)\n    \n    for i in range(num_datasets):\n        ax = axes[i // 4, i % 4]\n        A, B, post = posterior_model2(data[i], a_vals, b_vals)\n        ax.imshow(post, origin='lower', extent=[0.01, 0.99, 0.01, 0.99], aspect='auto', cmap='gray_r')\n        ax.plot(0.5, 0.3, 'ws', markersize=6, markeredgecolor='k')\n        \n        ax.set_xticks([0, 0.5, 1])\n        ax.set_yticks([0, 0.5, 1])\n        if i // 4 == 2:\n            ax.set_xlabel('a')\n        if i % 4 == 0:\n            ax.set_ylabel('b')\n            \n    plt.show()\n\n\n\nReproducing Figure 1.4 (\\(n = 100\\))\nAlthough \\(n=100\\) is a relatively large sample size, the posterior surfaces (for 12 independent samples) display chaotic geometries. Rather than single circular peaks, the distributions exhibit long, extended ridges and multiple local maxima.\n\n\nCode\nplot_model2(100)\n\n\n\n\n\n\n\n\n\n\n\nReproducing Figure 1.5 (\\(n = 1000\\))\nEven at \\(n=1000\\) (a 10-fold increase), the posterior fails to converge to a neatly shaped Gaussian point cloud. The shape of the distribution remains idiosyncratic, fundamentally dependent on the exact sample drawn. The unidentifiability limits parameter collapse in specific directions—demonstrated by the ‘stretched’ variance seen uniquely across the twelve trials. This highlights the inherent flaw in trying to approximate singular posterior distributions with single-point estimates (e.g. maximum likelihood) or simple quadratics (like the Laplace approximation).\n\n\nCode\nplot_model2(1000)"
  }
]